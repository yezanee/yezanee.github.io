---
title: "[프로그래머스] 더 맵게"
date: 2025-09-02 12:00:00 +0900
categories: [algorithm, 코딩테스트]
tags: [algorithm, 코딩테스트]
---


## ▪︎  문제

---

[프로그래머스 타겟 넘버](https://school.programmers.co.kr/learn/courses/30/lessons/43165)

<br>

## ▪︎  알고리즘 설계

---

- 각 숫자마다 **+ 혹은 -를 붙이는 경우의 수**를 모두 탐색해야 한다.
- 즉, 매 단계에서 두 갈래로 뻗어 나가는 **이진 트리 탐색(DFS)** 문제이다.
- 모든 숫자를 다 사용했을 때 누적합이 `target`과 일치하면 경우의 수를 1 증가시킨다.
- 재귀 함수를 이용해 인덱스와 누적합을 매개변수로 전달한다.

<br>

## ▪︎  코드

---

```java
class Solution {
    public int solution(int[] numbers, int target) {
        
        return dfs(numbers, 0, 0, target);
    }
    
    // 깊이 우선 탐색으로 모든 +/- 조합을 탐색
    public int dfs(int[] numbers, int idx, int sum, int target) {
        
        // 모든 숫자를 다 썼다면, 합이 target인지 확인
        if (idx == numbers.length) {
            return (sum == target) ? 1 : 0;
        }
        
        // 현재 숫자를 더하는 경우
        int count = dfs(numbers, idx + 1, sum + numbers[idx], target);
        
        // 현재 숫자를 빼는 경우
        count += dfs(numbers, idx + 1, sum - numbers[idx], target);
        
        return count;
    }
}
```

<br>

## ▪︎  시간복잡도

---

`O(2^N)`

<br>

## ▪︎  틀린 이유

---

- 재귀로 탐색해야된다는 것에 대한 인식은 있었지만, 막상 구현을 하려고 할 때 막혔다.
- 파라미터로 어느 값들을 전달해줘야 할지 판단이 부족했다.

<br>

## ▪︎  느낀점 / 기억할 정보

---

- “경우의 수를 모두 따지는 문제 = 재귀(DFS/BFS)로 상태 탐색” 패턴을 떠올릴 것.
- 단순히 배열을 돌면서 값을 바꾸는 방식은 오답으로 이어질 수 있다.
- **재귀 함수는 항상 현재 상태를 파라미터로 전달**해야 예측 가능한 동작을 만든다.