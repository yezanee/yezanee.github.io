---
title: 4. 자료구조
date: 2025-02-05 12:01:00 +0900
categories:
  - 알고리즘
  - Do it! 알고리즘 코딩테스트 자바
tags:
  - 알고리즘
  - 코딩테스트
---

# 4.1 배열과 리스트

## 배열과 리스트의 핵심 이론

### **배열**

- 메모리의 **연속 공간에 값이 채워져 있는 형태의 자료구조**
- 배열의 값은 **인덱스**를 통해 참조할 수 있으며, **선언한 자료형의 값만 저장**할 수 있다.

<br>

![배열 구조](/assets/img/post/img5.png)

<br>

**배열의 특징**

1. **인덱스를 사용하여 값에 바로 접근할 수 있다.**
2. **새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.** 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.
3. **배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 늘리거나 줄일 수 없다.**
4. **구조가 간단하므로 코딩 테스트에서 많이 사용한다.**

<br>

### **리스트**

- **값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조**
- 노드는 컴퓨터 과학에서 **값과 포인터를 쌍으로 갖는 기초 단위를 부르는 말이다.**

<br>

![리스트 구조](/assets/img/post/img6.png)

<br>

**리스트의 특징**

1. **인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.** 다시 말해 값에 접근하는 속도가 느리다.
2. **포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.**
3. **선언할 때 크기를 별도로 지정하지 않아도 된다.** 다시 말해 리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
4. **포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.**

<br>

## 문제 001 : 숫자의 합 구하기

<br>

![문제 001](/assets/img/post/img7.png)

<br>

### 풀이

```java
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int N = Integer.parseInt(br.readLine()); // 숫자의 개수
		String str = br.readLine();
		int sum = 0;
		
		for (int i=0; i<N; i++) {
			sum += str.charAt(i) - '0';
		}
		
		System.out.println(sum);
	}
}
```

<br>

### 오답노트

- **`Integer.parseInt(str.charAt(i))` 는 불가능하다.**
    - **Integer.parseInt()는 String만 받을 수 있다.**
    - 따라서 이를 해결하기 위한 2가지 방법이 있다.
    - **방법1: `sum += str.charAt(i) - '0';`**
        - 아스키 코드 이용하여 문자를 숫자로 변환
    - **방법2: `sum += Integer.parseInt(String.valueOf(str.charAt(i)));` 또는 `sum += str.charAt(i) - '0';`**
        - 문자 → 문자열 → 정수
- **`StringTokenizer st = new StringTokenizer(br.readLine(), "");`는 불가능.**
    - **StringTokenizer는 구분자가 반드시 1글자 이상이어야 한다.** `“”`(빈 문자열)는 구분자가 될 수 없다.
    - 내부적으로 `IllegalArgumentException` 또는 `NoSuchElementException` 문제 발생

<br>

### 책에서의 풀이

```java
import java.util.Scanner;

public class P11720_숫자의합 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();

        // 입력값을 String형 변수 sNum에 저장한 후 char[]형 변수로 변환하기
        String sNum = sc.next();
        char[] cNum = sNum.toCharArray();

        int sum = 0;

        for (int i = 0; i < cNum.length; i++) {
            sum += cNum[i] - '0';   // cNum[i]를 정수형으로 변환하면서 sum에 더하여 누적하기
        }

        System.out.print(sum);
    }
}
```

<br>

### 팁

- **자바에서의 형 변환**
    - String형 → 숫자형
        
        ```java
        String sNum = "1234";   // string형 변수
        
        int i1 = Integer.parseInt(sNum);
        int i2 = Integer.valueOf(sNum);
        
        double d1 = Double.parseDouble(sNum);
        double d2 = Double.valueOf(sNum);
        
        float f1 = Float.parseFloat(sNum);
        float f2 = Float.valueOf(sNum);
        
        long l1 = Long.parseLong(sNum);
        long l2 = Long.valueOf(sNum);
        
        short s1 = Short.parseShort(sNum);
        short s2 = Short.valueOf(sNum);
        ```
        
    - 숫자형 → String형
        
        ```java
        int i = 1234;
        String i1 = String.valueOf(i);
        String i2 = Integer.toString(i);
        
        double d = 1.23;
        String d1 = String.valueOf(d);
        String d2 = Double.toString(d);
        
        float f = (float) 1.23;
        String f1 = String.valueOf(f);
        String f2 = Float.toString(f);
        
        long l = 1234;
        String l1 = String.valueOf(l);
        String l2 = Long.toString(l);
        
        short s = 1234;
        String s1 = String.valueOf(s);
        String s2 = Short.toString(s);
        ```

<br>

## 문제 002 : 평균 구하기

<br>

![문제 002](/assets/img/post/img8.png)

<br>

### 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int N = Integer.parseInt(br.readLine());
		int[] score = new int[N];
		double sum = 0;
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		for(int i=0; i<N; i++) {
			score[i] = Integer.parseInt(st.nextToken());
		}
		
		Arrays.sort(score);
		int max = score[N-1];
		
		for(int i=0; i<N; i++) {
			sum += (double)score[i]/max*100;
		}
		
		System.out.println(sum/N);
	}
}
```

### 오답노트

- **StringTokenizer 생성 시점 문제**
    - `StringTokenizer`를 `BufferedReader` 생성 후 바로 생성해주었을 때는 런타임 에러가 발생했다.
    - 런타임 에러를 일으킨 이유는 **입력을 읽는 순서가 잘못되었기 때문**이다.
    - 토크나이저가 첫 줄(`N`)을 먼저 읽어버려서 실제 점수 줄을 분해하지 못했고, 그 상태에서 `nextToken()`을 호출하자 **꺼낼 토큰이 없어 에러가 발생했다.**
    - 즉, `StringTokenizer`는 생성 시점에 읽은 문자열만 분해하기 때문에 반드시 **개수(N)를 먼저 읽고, 그 다음 줄을 토큰화해야 하며**, 이 순서가 바뀌면 입력 데이터가 꼬여 런타임 에러가 발생한다.
- **형변환 주의**
    - score와 max 모두 int 형이므로, 나누면 몫만 남게됨. 따라서 double형 변환 해야함.

### 책에서의 풀이

```java
public class P1546_평균 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();

        int A[] = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }

        long sum = 0;
        long max = 0;

        for (int i = 0; i < N; i++) {
            if (A[i] > max) max = A[i];
            sum = sum + A[i];
        }

        // 한 과목과 관련된 수식을 종합과 관련된 수식으로 변환해 로직이 간단해짐
        System.out.println(sum * 100.0 / max / N);
    }
}
```

<br>

# 4.2 구간 합

## 구간 합의 핵심 이론

### 합 배열 S 정의

**`S[i] = A[0] + A[1] + A[2] + ... A[i-1] + A[i]`** 

합 배열은 기존 배열을 전처리한 배열이라고 생각하면 된다.

이렇게 합 배열을 미리 구해놓으면 기존 배열의 일정 범위 합을 구하는 시간 복잡도가 O(N)에서 O(1)로 감소한다. 다음 그림을 통해 합 배열을 좀 더 자세히 설명해보겠다.

<br>

![합 배열 설명](/assets/img/post/img9.png)

<br>

A[i]부터 A[j]까지의 배열 합을 합 배열 없이 구하는 경우, 최악의 경우는 i가 0이고 j가 N인 경우로 시간 복잡도는 O(N)이다.

이런 경우 앞에서 알아본 합 배열을 사용하면 O(1) 안에 답을 구할 수 있다.

### 합 배열 S를 만드는 공식

**`S[i] = S[i-1] + A[i]`**

이렇게 구현된 합 배열을 이용하여 구간 합 역시 쉽게 구할 수 있다. i에서 j까지 구간 합을 구하는 공식은 다음과 같다.

### 구간 합을 구하는 공식

**`S[j] - S[i-1]`**

구간 합 공식이 어떻게 나온 것인지 다음 그림을 통해 자세히 알아보겠다.

다음 그림은 배열 A의 A[2]부터 A[5]까지의 구간 합을 합 배열을 통해 구하는 과정을 보여준다.

<br>

![구간 합 설명](/assets/img/post/img10.png)

<br>

그림을 보면 합 배열과 구간 합이 연결되어 있다는 것을 알 수 있다. 합 배열만 미리 구현해 두면 구간 합은 한 번의 계산으로 구할 수 있다.

### A[2] ~ A[5] 구간 합을 합 배열로 구하는 과정

S[5] = A[0] + A[1] + A[2] + A[3] + A[4] + A[5]

S[1] = A[0] + A[1]

S[5] − S[1] = A[2] + A[3] + A[4] + A[5]

<br>

## 문제 003 : 구간 합 구하기

<br>

![문제 003](/assets/img/post/img11.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
				
		int N = Integer.parseInt(st.nextToken()); // 개수
		int M = Integer.parseInt(st.nextToken()); // 합을 구해야 하는 횟수
		
		int[] prefix = new int[N+1];
		
		st = new StringTokenizer(br.readLine());
		for(int i=1; i<N; i++) {
			int x = Integer.parseInt(st.nextToken());
			prefix[i] = prefix[i-1]+x; // 1번부터 i번까지의 누적합
		}
		
		StringBuilder sb = new StringBuilder();
		for(int i=0; i<M; i++) {
			st = new StringTokenizer(br.readLine());
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			
			int sum = prefix[end] - prefix[start-1];
			sb.append(sum).append('\n');
		}
		
		System.out.println(sb.toString());
	}
}			
```

<br>

### 오답노트

- **StringTokenizer 생성 시점**
    
    ```java
    st = new StringTokenizer(br.readLine());
    
    for (int i = 0; i < M; i++) {
        start = Integer.parseInt(st.nextToken());
        end = Integer.parseInt(st.nextToken());
    }
    ```
    
    - 질의는 **M줄로 입력**되는데 `StringTokenizer`를 **한 번만 생성함** → 다음 질의에서 읽을 토큰이 없어짐
    - 입력 한 줄 = StringTokenizer 한 번 생성
- **StringBuilder**
    - 한번에 출력하기 위해
- **sum 선언위치**
    
    ```java
    int sum = 0;
    
    for (int i = 0; i < M; i++) {
        // sum 초기화 없음
    }
    ```
    
    - 이전 구간합 결과가 다음 계산에 누적됨
    - 질의 간 값이 섞임
- **구간합 공식 활용 못함**
    - 배열 초기화 값 0이다.
    - 숫자 N개가 주어진다.
    - M번 동안 **start ~ end 구간의 합**을 구해야 한다.
    - `int sum = prefix[end] - prefix[start - 1];` 이용

<br>

### 책에서의 풀이

```java
public class P11659_구간합구하기 {
	public static void main(String[] args) throws IOException {
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());

    int suNo = Integer.parseInt(stringTokenizer.nextToken());
    int quizNo = Integer.parseInt(stringTokenizer.nextToken());

    long[] S = new long[suNo + 1];

    stringTokenizer = new StringTokenizer(bufferedReader.readLine());

    for (int i = 1; i <= suNo; i++) {
	    S[i] = S[i - 1] + Integer.parseInt(stringTokenizer.nextToken());
    }

    for (int q = 0; q < quizNo; q++) {
			stringTokenizer = new StringTokenizer(bufferedReader.readLine());

			int i = Integer.parseInt(stringTokenizer.nextToken());
      int j = Integer.parseInt(stringTokenizer.nextToken());

      System.out.println(S[j] - S[i - 1]);
    }
	}
}
```

## 문제 004 : 구간 합 구하기 2

<br>

![문제 004](/assets/img/post/img12.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int N = Integer.parseInt(st.nextToken()); // 표의 크기
		int M = Integer.parseInt(st.nextToken()); // 합을 구해야 하는 개수
		int[][] matrix = new int[N+1][N+1];
		
		for(int i=1; i<=N; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=1; j<=N; j++) {
				matrix[i][j] = matrix[i][j-1] + Integer.parseInt(st.nextToken());
			}
		}
		
		StringBuilder sb = new StringBuilder();
		for(int i=0; i<M; i++) {
			st = new StringTokenizer(br.readLine());
			int x1 = Integer.parseInt(st.nextToken());
			int y1 = Integer.parseInt(st.nextToken());
			int x2 = Integer.parseInt(st.nextToken());
			int y2 = Integer.parseInt(st.nextToken());
			
			long sum = 0;
			for(int j=x1; j<=x2; j++) {
				sum += matrix[j][y2] - matrix[j][y1-1];
			}
			
			sb.append(sum).append('\n');
		}
		
		System.out.println(sb.toString());
	}
}
```

<br>

### 오답노트

- 배열 행과 열
    - `arr[세로][가로]`
    - **수학 좌표계와 헷갈렸는데, y가 가로를 나타내는 것.**

<br>

### 책에서의 풀이

- 2차원 구간 합 배열 D[X][Y] 정의
  - D[X][Y] = 원본 배열의 (0, 0)부터 (X, Y)까지의 사각형 안에 있는 수의 합

  <br>

  ![2차원 구간 합 D 정의](/assets/img/post/img13.png)

  <br>

- D[i][j]의 값을 채우는 구간 합 공식
  - D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]

  <br>

  ![D[i][j] 공식](/assets/img/post/img14.png)

  <br>

  ![구간 합 예시](/assets/img/post/img15.png)

  <br>

  - 예를 들어 질의가 2 2 3 4라면, (3, 4) 구간 합에서 (1, 4) 구간 합, (3, 1) 구간 합을 뺀 다음 중복하여 뺀 (1, 1) 구간 합을 더하면 된다.
  - 원본 배열에 표시한 구간 합을 다시 구간 합 배열에 표시하면 다음과 같다.

  <br>

  ![구간 합 배열 표시](/assets/img/post/img16.png)

  <br>

```java
public class P11660_구간합구하기2 {
    public static void main(String[] args) throws Exception {

        BufferedReader br =
                new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int A[][] = new int[N + 1][N + 1];

        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= N; j++) {
                A[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        int D[][] = new int[N + 1][N + 1];

        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                // 구간 합 구하기
                D[i][j] = D[i][j - 1]
                        + D[i - 1][j]
                        - D[i - 1][j - 1]
                        + A[i][j];
            }
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());

            int x1 = Integer.parseInt(st.nextToken());
            int y1 = Integer.parseInt(st.nextToken());
            int x2 = Integer.parseInt(st.nextToken());
            int y2 = Integer.parseInt(st.nextToken());

            // 구간 합 배열로 질의에 답변하기
            int result =
                    D[x2][y2]
                  - D[x1 - 1][y2]
                  - D[x2][y1 - 1]
                  + D[x1 - 1][y1 - 1];

            System.out.println(result);
        }
    }
}
```

## 문제 005 : 나머지 합 구하기

<br>

![스크린샷 2026-02-02 오후 12.01.01.png](/assets/img/post/img17.png)

<br>

### 풀이 (책에서의 풀이)

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
		
		long[] sum = new long[N+1];
		long[] indexCnt = new long[M];
		long result = 0;
		
		st = new StringTokenizer(br.readLine());
		for(int i=1; i<=N; i++) {
			sum[i] = sum[i-1] + Long.parseLong(st.nextToken());
		}
		
		for(int i=1; i<=N; i++) {
			long remainder = sum[i] % M;
			
			// 0 ~ i까지의 구간 합 자체가 0일 때 정답에 더하기
			if(remainder == 0) result++;
			
			// 나머지가 같은 인덱스의 개수 카운팅하기
			indexCnt[(int)remainder]++;
		}
		
		for(int i = 0; i < M; i++) {
			if(indexCnt[i] > 1) {
				// 나머지가 같은 인덱스 중 2개를 뽑는 경우의 수를 더하기
				result = result + (indexCnt[i] * (indexCnt[i]-1) / 2);
			}
		}
		System.out.println(result);
	}
}		
```

### 오답노트

- StringTokenizer(br.readLine()): 한 줄을 받음 (문자가 몇개든, 한 줄)
- **시간 초과 코드**
    
    ```java
    import java.util.*;
    import java.io.*;
    
    public class Main {
    	public static void main(String[] args) throws IOException {
    		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    		StringTokenizer st = new StringTokenizer(br.readLine());
    		
    		int N = Integer.parseInt(st.nextToken());
    		int M = Integer.parseInt(st.nextToken());
    		
    		int[] sum = new int[N+1];
    		int cnt = 0;
    		
    		st = new StringTokenizer(br.readLine());
    		for(int i=1; i<=N; i++) {
    			sum[i] = sum[i-1] + Integer.parseInt(st.nextToken());
    			if(sum[i] % M == 0) cnt++;
    		}
    		
    		for(int i=1; i<N; i++) {
    			for(int j=i+1; j<=N; j++) {
    				if((sum[j] - sum[i]) % M == 0) cnt++;
    			}
    		}
    		
    		System.out.println(cnt);
    	}
    }	
    ```
    

### 나머지 합 문제 풀이의 핵심 아이디어

- (A + B) % C는 ((A % C) + (B % C)) % C와 같다. 다시 말해 특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합에 나머지 연산을 한 값은 동일하다.
- 구간 합 배열을 이용한 식 S[j] - S[i]는 원본 배열의 i + 1부터 j까지의 구간 합이다.
- **S[j] % M의 값과 S[i] % M의 값이 같다면 (S[j] - S[i]) % M은 0이다.** 즉, 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트하고 S[j]와 S[i]가 같은 (i, j)쌍을 찾으면 원본 배열에서 i + 1부터 j까지의 구간 합이 M으로 나누어떨어진다는 것을 알 수 있다.

1. **A 배열의 합 배열 S를 생성한다.**
    
    ![스크린샷 2026-02-02 오후 12.21.53.png](/assets/img/post/img18.png)
    
2. **합 배열 S의 모든 값에 대해 M으로 나머지 연산을 수행해 값을 업데이트.**
    
    ![스크린샷 2026-02-02 오후 12.21.58.png](/assets/img/post/img19.png)
    
3. **우선 변경된 합 배열에서 원소 값이 0인 개수만 세어 정답에 더한다.**
    1. 변경된 합 배열의 원소 값이 0이라는 뜻은 **원본 배열의 0부터 i까지의 구간 합이 이미 M으로 나누어떨어진다는 뜻**이기 때문
4. 이제 변경된 합 배열에서 **원소 값이 같은 인덱스의 개수**, 즉 **나머지 값이 같은 합 배열의 개수를 센다.**
    1. 변경된 합 배열에서 원소 값이 같은 2개의 원소를 뽑는 모든 경우의 수를 구하여 정답에 더하면 된다.
    2. 위의 예에서는 0이 3개, 1이 2개이므로 3C2, 2C2로 경우의 수를 구하여 더하면 된다.
    3. 총 경우의 수 = 3 + 3 + 1 = 7

# 4.3 투 포인터

## 투 포인터의 핵심 이론

- 2개의 포인터로 알고리즘의 시간 복잡도를 최적화한다.

## 문제 006 : 연속된 자연수의 합 구하기

<br>

![스크린샷 2026-02-03 오후 12.06.53.png](/assets/img/post/img20.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(br.readLine());
		int cnt = 1;
		int[] arr = new int[N+1];
		int sum = 1;
		int startIdx = 1;
		int endIdx = 1;
		
		while(endIdx != N) {
			
			if(sum > N) {
				sum = sum - startIdx;
				startIdx++;
			} else if (sum < N) {
				endIdx++;
				sum = sum + endIdx;
			} else {
				endIdx++;
				sum = sum + endIdx;
				cnt++;
			}
		}
		System.out.println(cnt);
	}
}		
```

- 시간 제한은 2초인데, N의 최댓값은 매우 크므로 O(n)의 시간 복잡도 알고리즘을 사용해야 한다. 이런 경우 자주 사용하는 방법이 **투 포인터**이다.
- 연속된 자연수의 합을 구하는 문제이므로 시작 인덱스와 종료 인덱스를 지정하여 연속된 수를 표현한다.

### **동작 방식 이해**

- `N = 15`
    - 시작 상태
        
        `start = 1`, `end = 1`, `sum = 1`
        
    - `sum < 15` 이므로 오른쪽 확장
        
        `1 + 2 = 3`
        
        `1 + 2 + 3 = 6`
        
        `1 + 2 + 3 + 4 = 10`
        
        `1 + 2 + 3 + 4 + 5 = 15`
        
        - 합이 `N`과 같아짐 → 경우의 수 증가 (`cnt = 1`)
    - 다음 경우를 찾기 위해 다시 오른쪽 확장
        
        `1 + 2 + 3 + 4 + 5 + 6 = 21`
        
        - `sum > 15` 이므로 왼쪽 축소
            
            `2 + 3 + 4 + 5 + 6 = 20`
            
            `3 + 4 + 5 + 6 = 18`
            
            `4 + 5 + 6 = 15`
            
            - 합이 `N`과 같아짐 → 경우의 수 증가 (`cnt = 2`)
    - 다시 오른쪽 확장
        
        `4 + 5 + 6 + 7 = 22`
        
        - `sum > 15` 이므로 왼쪽 축소
            
            `5 + 6 + 7 = 18`
            
            `6 + 7 = 13`
            
    - `sum < 15` 이므로 오른쪽 확장
        
        `6 + 7 + 8 = 21`
        
        - `sum > 15` 이므로 왼쪽 축소
            
            `7 + 8 = 15`
            
            - 합이 `N`과 같아짐 → 경우의 수 증가 (`cnt = 3`)
    - 마지막으로 `15` 하나만 사용하는 경우
        
        `15 = 15`
        
        - 경우의 수 증가 (`cnt = 4`)

→ **합이 작으면 오른쪽을 늘리고, 합이 크면 왼쪽을 줄이는 과정을 반복하면서 연속된 자연수 구간을 한 번씩만 검사하고, 합이 N이 되는 순간마다 경우의 수를 센다.**

## 문제 007 : 주몽의 명령

<br>

![스크린샷 2026-02-03 오후 12.37.58.png](/assets/img/post/img21.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int N = Integer.parseInt(br.readLine()); // 재료의 개수
		long M = Integer.parseInt(br.readLine()); // 갑옷을 만드는데 필요한 수
		
		int[] nums = new int[N];
		StringTokenizer st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(st.nextToken());
		}
		
		Arrays.sort(nums);
		
		int firstIdx = 0;
		int secondIdx = N-1;
		int cnt = 0;
		
		while(firstIdx < secondIdx) {
			long sum = (long) nums[firstIdx] + nums[secondIdx];
			if (sum == M) {
				cnt++;
				firstIdx++;
				secondIdx--;
			} else if (sum < M) {
				firstIdx++;
			} else {
				secondIdx--;
			}
		}
		
		System.out.println(cnt);
		br.close();
	}
}
		
```

### 위의 투 포인터 방식으로 모든 경우의 수를 다 찾을 수 있는 이유

- 이 알고리즘은 ‘가능한 경우를 하나씩 만들어가는 방식’이 아니라 **’불가능한 경우를 논리적으로 제거해 나가는 방식’**
- 처음에 포인터를 **배열의 양 끝**, 즉 가장 작은 값과 가장 큰 값에 두는 이유는 이 두 값의 합이 현재 만들 수 있는 합 중 극단값이기 때문이다.
    - 이 상태에서 합이 M보다 작다면, 가장 큰 값과 더했는데도 부족하다는 뜻이므로 현재 왼쪽 값은 어떤 값과도 M을 만들 수 없다고 판단할 수 있고, 따라서 그 값을 포함하는 모든 조합을 한 번에 버리고 왼쪽 포인터를 오른쪽으로 이동시킨다.
    - 반대로 합이 M보다 크다면, 가장 작은 값과 더했는데도 초과했다는 의미이므로 현재 오른쪽 값 역시 어떤 값과도 M을 만들 수 없고, 그 값을 포함하는 모든 조합을 버리면서 오른쪽 포인터를 왼쪽으로 이동시킨다.
    - 이처럼 포인터 이동 하나는 단순한 위치 변경이 아니라, **특정 값이 포함된 모든 조합을 논리적으로 제거하는 행위**이기 때문에, 중복이나 누락 없이 탐색 범위가 줄어든다.
- 합이 정확히 M이 되는 경우에는 두 포인터가 가리키는 값이 하나의 유효한 조합을 이룬다는 뜻이며, **이 문제에서는 각 재료를 한 번만 사용할 수 있으므로** 이 두 값은 더 이상 고려 대상이 아니다. 따라서 카운트를 증가시킨 뒤 왼쪽 포인터와 오른쪽 포인터를 모두 이동시켜 두 값을 동시에 제거한다.
- 만약 이때 한쪽 포인터만 이동한다면, 이미 사용한 재료를 다시 다른 값과 조합하려는 시도가 포함되어 문제 조건과 어긋나거나, 중복 탐색이 발생하게 된다.

## 문제 008 : ‘좋은 수’ 구하기

<br>

![스크린샷 2026-02-03 오후 1.27.00.png](/assets/img/post/img22.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int N = Integer.parseInt(br.readLine());
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		long[] A = new long[N];
		
		for(int i=0; i<N; i++) {
			A[i] = Long.parseLong(st.nextToken());
		}
		
		Arrays.sort(A);
		
		int cnt = 0;
		
		for(int i=0; i<N; i++) {
			int firstIdx = 0;
			int secondIdx = N-1;
			
			while(firstIdx < secondIdx) {
				long sum = A[firstIdx] + A[secondIdx];
				
				if (firstIdx == i) { firstIdx++; continue; }
				if (secondIdx == i) { secondIdx--; continue; }
				
				if (sum == A[i]) {
					cnt++;
					break;
				} else if (sum < A[i]) {
					firstIdx++;
				} else if (sum > A[i]) {
					secondIdx--;
				}
			}
		}
		
		System.out.println(cnt);
	}
}
```

### 오답노트

- **왜 `i = 2`부터 시작하면 안 되나**
    - 문제 조건에서 **원소가 같을 수도 있기 때문이다.**
    - **반례: [0 0 0]**
        - 첫 번째 0은 나머지 두 0의 합으로 만들 수 있고, 두 번째 0도 마찬가지이며, 세 번째 0 역시 앞의 두 0의 합으로 만들 수 있다. 즉 세 값 모두 좋은 수이고 정답은 3이다.
        - 하지만 for문을 `i = 2`부터 시작하면 앞의 두 원소는 애초에 검사 대상에서 제외되어 버린다. 문제에서는 검사할 가치가 없는 원소가 존재하지 않는데, 코드에서 임의로 A[0], A[1]을 빼버리는 셈이 되어 반례가 바로 발생한다.
- **왜 `secondIdx = N-1`이어야 하나**
    - 문제 조건에 원소가 **음수도 가능하기 때문이다.**
    - **반례: `[-2, -1, 3, 4]`**
        - 정렬된 상태에서 `3`을 기준으로 보면, 이 값은 `-1 + 4`로 만들 수 있으므로 좋은 수다. 그런데 `secondIdx = i - 1`로 두면 오른쪽에 있는 `4`를 아예 고려하지 못한다.
        - 반대로 `firstIdx = 0`, `secondIdx = N-1`에서 시작하면 배열 전체를 열어 둔 상태에서 두 수를 탐색할 수 있고, 오직 자기 자신인 `i`만 제외하면 문제 조건과 정확히 일치한다.
- **왜 `firstIdx == i`, `secondIdx == i`를 건너뛰어야 하나**
    - 이건 **자기 자신을 재료로 써서 자기 자신을 만든 것**이라 문제에서 금지한 케이스다(서로 다른 두 수 조건 위반)

### 책에서의 풀이

```java
public class P1253_좋은수 {

    public static void main(String[] args) throws NumberFormatException, IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        int Result = 0;

        long A[] = new long[N];
        StringTokenizer st = new StringTokenizer(bf.readLine());
        for (int i = 0; i < N; i++) {
            A[i] = Long.parseLong(st.nextToken());
        }

        Arrays.sort(A);

        for (int k = 0; k < N; k++) {
            long find = A[k];
            int i = 0;
            int j = N - 1;

            // 투 포인터 알고리즘
            while (i < j) {
                if (A[i] + A[j] == find) {
                    // find가 서로 다른 두 수의 합인지 체크하기
                    if (i != k && j != k) {
                        Result++;
                        break;
                    } else if (i == k) {
                        i++;
                    } else if (j == k) {
                        j--;
                    }
                } else if (A[i] + A[j] < find) {
                    i++;
                } else {
                    j--;
                }
            }
        }

        System.out.println(Result);
        bf.close();
    }
}

```

- **`throws NumberFormatException`**
    - `NumberFormatException`: **문자열을 숫자로 바꾸려 할 때 형식이 잘못되면 발생하는 예외**
    - main 메서드 안에서 NumberFormatException이 발생하면 여기서 try-catch로 처리하지 않고 JVM에게 그대로 던진다는 뜻
    - 사실상 의미가 거의 없는 선언
        - `throws`는 **컴파일러가 예외 처리를 강제하기 위한 문법**인데, `NumberFormatException`은 `RuntimeException`이라 애초에 컴파일러가 처리 여부를 강제하지 않으므로 `throws NumberFormatException`을 써도 안 써도 컴파일·실행·동작이 전혀 달라지지 않아 사실상 의미가 없다.

# 4.4 슬라이딩 윈도우

## 슬라이딩 윈도우의 핵심 이론

- 2개의 포인터로 범위를 지정한 다음, 범위를 유지한 채로 이동하며 문제를 해결한다.

## 문제 009 : DNA 비밀번호

<br>

![스크린샷 2026-02-03 오후 2.15.12.png](/assets/img/post/img23.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	static char[] dnaStrToArr;
	static int[] cntArr = new int[4];
	
	public static void check(int idx, int sign) {
			if(dnaStrToArr[idx] == 'A') cntArr[0] += sign;
			else if (dnaStrToArr[idx] == 'C') cntArr[1] += sign;
			else if (dnaStrToArr[idx] == 'G') cntArr[2] += sign;
			else if (dnaStrToArr[idx] == 'T') cntArr[3] += sign;
	}
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int S = Integer.parseInt(st.nextToken()); // 문자열 길이
 		int P = Integer.parseInt(st.nextToken()); // 부분 문자열 길이
 		
 		String dnaStr = br.readLine();
 		dnaStrToArr = dnaStr.toCharArray();
 		
	 	int[] minCnt = new int[4]; // 부분문자열에 포함되어야 할 최소값
 		st = new StringTokenizer(br.readLine());
 		for(int i=0; i<4; i++) {
	 		minCnt[i] = Integer.parseInt(st.nextToken());
	 	}
	 	
	 	int startIdx = 0;
	 	int endIdx = P-1;
	 	int cnt = 0;
	 	
		for(int i = startIdx; i<=endIdx; i++) {
			check(i, 1);
		}
		
		if (cntArr[0] >= minCnt[0] && cntArr[1] >= minCnt[1]
			&& cntArr[2] >= minCnt[2] && cntArr[3] >= minCnt[3]) cnt++;
			
	 	while(endIdx < S-1) {	
	 	
		 	check(startIdx, -1);
		 	startIdx++;
		 	endIdx++;
		 	check(endIdx, 1);
			
			if (cntArr[0] >= minCnt[0] && cntArr[1] >= minCnt[1]
				&& cntArr[2] >= minCnt[2] && cntArr[3] >= minCnt[3]) cnt++;
		}
		
		System.out.println(cnt);
	}
}
```

### 오답노트

- **`dnaStrToArr[i] = (char) dnaStr.substring(i, i+1);` 불가능**
    - **대체**
        - **`string.charAt(index)`**
        - **`string.toCharArray()`**
- **시간 초과**
    
    ```java
    import java.util.*;
    import java.io.*;
    
    public class Main {
    	public static void main(String[] args) throws IOException {
    		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    		StringTokenizer st = new StringTokenizer(br.readLine());
    		
    		int S = Integer.parseInt(st.nextToken()); // 문자열 길이
     		int P = Integer.parseInt(st.nextToken()); // 부분 문자열 길이
     		
     		String dnaStr = br.readLine();
     		char[] dnaStrToArr = dnaStr.toCharArray();
     		int[] minCnt = new int[4]; // 부분문자열에 포함되어야 할 최소 개수
     		
     		st = new StringTokenizer(br.readLine());
     		for(int i=0; i<4; i++) {
    	 		minCnt[i] = Integer.parseInt(st.nextToken());
    	 	}
    	 	
    	 	int startIdx = 0;
    	 	int endIdx = P-1;
    	 	int cnt = 0;
    	 	
    	 	while(endIdx < S) {
    		 	int[] cntArr = new int[4];
    		 	for(int i = startIdx; i<endIdx; i++) {
    			 	if(dnaStrToArr[i] == 'A') {
    				 	cntArr[0]++;
    				} else if (dnaStrToArr[i] == 'C') {
    					cntArr[1]++;
    				} else if (dnaStrToArr[i] == 'G') {
    					cntArr[2]++;
    			 	} else if (dnaStrToArr[i] == 'T') {
    				 	cntArr[3]++;
    				}
    			}
    			
    			if (cntArr[0] >= minCnt[0] && cntArr[1] >= minCnt[1]
    					&& cntArr[2] >= minCnt[2] && cntArr[3] >= minCnt[3]) {
    						cnt++;
    			}
    			
    			startIdx++;
    			endIdx++;
    		}
    		
    		System.out.println(cnt);
    	}
    }
    ```
    
- 처음에 시간 초과와 오답이 난 가장 큰 이유는 슬라이딩 윈도우의 핵심 개념을 부분적으로만 적용했기 때문이다.
    - 초기에 매 구간마다 배열을 새로 만들어 전체를 다시 세는 방식은 O(S×P)가 되어 시간 초과가 났고, 이를 개선하려고 슬라이딩 윈도우를 적용했지만 **“개수는 누적해서 관리한다”**는 전제가 무너져 있었다.
- 그 다음 문제는 **초기 윈도우 구성 오류**였다.
    - 길이가 P인 첫 부분 문자열을 세야 하는데, 반복문을 `i < endIdx`로 작성해 `endIdx(P-1)` 위치의 문자를 빼먹었다. 이로 인해 첫 검사는 이미 잘못된 상태에서 시작했고, 이후 슬라이딩 과정도 한 칸씩 어긋난 상태로 진행되어 결과가 계속 틀어졌다.
    - 슬라이딩 윈도우에서는 “처음 P개를 정확히 세고 → 이후에는 하나 빼고 하나 더한다”라는 흐름이 절대 깨지면 안 된다는 점을 놓친 것이 핵심 실수였다.

### 자바의 접근 제어자

- **`public`**
    - `public`은 **가장 개방적인 접근 제어자**로, 같은 클래스·같은 패키지·다른 패키지 여부와 상관없이 **어디서든 접근 가능**하다.
    - 외부에 공개해야 하는 API, 라이브러리의 인터페이스, `main` 메서드처럼 JVM이 호출해야 하는 메서드에 사용된다.
- **`protected`**
    - `protected`는 **같은 패키지에서는 자유롭게 접근 가능**하고, 패키지가 달라도 **상속받은 자식 클래스에서는 접근 가능**하다.
    - 상속 구조에서 부모 클래스가 “자식에게는 허용하지만, 아무 클래스에게나 열어두고 싶지는 않을 때” 사용하는 제어자다. 라이브러리나 프레임워크에서 확장을 고려한 설계에 자주 등장한다.
- **`default` (package-private)**
    - 아무 접근 제어자도 붙이지 않으면 `default` 상태가 되며, 이는 **같은 패키지 안에서만 접근 가능**하다는 뜻이다. 패키지를 하나의 묶음(모듈)처럼 쓰고, 내부 구현은 숨기고 싶을 때 사용된다. 외부 패키지에서는 아예 보이지 않기 때문에 “패키지 내부용 코드”라는 의도가 가장 잘 드러난다.
- **`private`**
    - `private`는 **가장 강력한 접근 제한**으로, **선언된 클래스 내부에서만 접근 가능**하다. 다른 클래스는 물론이고, 같은 패키지라도 접근할 수 없다.
    - 객체의 내부 상태를 보호하기 위해 필드에 가장 많이 사용되며, 캡슐화의 핵심이다. 외부에서 직접 건드리면 안 되는 값이나 로직을 숨길 때 쓰인다.

### `static`

- `static` 은 **객체에 속하지 않고, 클래스 자체에 속한다**는 뜻이다.
- 보통 자바에서 메서드나 변수는 `new`로 객체를 만들어야 사용하지만, `static` 이 붙으면 객체 없이도 클래스 이름으로 바로 접근할 수 있다.
- `static` 멤버는 **메모리에 딱 한 번만 생성**되고, 모든 객체가 그 하나를 공유한다. 그래서 값이 바뀌면, 그 클래스의 모든 객체에서 동일하게 바뀐 값이 보인다. 이 때문에 `static` 변수는 전역 변수처럼 동작하고, 잘못 쓰면 상태 관리가 꼬이기 쉽다.
- 또한 **static 메서드에서는 static 멤버만 직접 접근 가능**하다. 객체가 없기 때문에 인스턴스 변수나 인스턴스 메서드는 사용할 수 없다. 이게 네가 `check()`나 `cntArr`를 static으로 만들어야 했던 이유다.

## 문제 10 : 최솟값 찾기

<br>

![스크린샷 2026-02-03 오후 3.20.08.png](/assets/img/post/img24.png)

<br>

### 틀린 풀이 ••

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		StringBuilder sb = new StringBuilder();
		
		int N = Integer.parseInt(st.nextToken());
		int L = Integer.parseInt(st.nextToken());
		
		st = new StringTokenizer(br.readLine());
		long[] nums = new long[N];
		for(int i=0; i<N; i++) {
			nums[i] = Long.parseLong(st.nextToken());
		}
		
		int start = 0;
		int end = L-1;
		long min = nums[0];
		for(int i=start; i<=end; i++) {
			min = Math.min(nums[i], min);
		}
		
		sb.append(min).append(' ');
		
		while(end < N-1) {
			start++;
			end++;
			if(min == nums[start-1]) {
				min = nums[start];
				for(int i=start; i<= end; i++) {
					min = Math.min(nums[i], min);
				}
			}
			if(nums[end] < min) { min = nums[end]; }
			
			sb.append(min).append(' ');
		}
		
		System.out.println(sb.toString());
	}
}
```

- 지금 코드는 **논리 자체가 “최솟값을 갱신하는 방식”을 잘못 잡아서** 특정 케이스에서 최소값이 깨지고, 그 결과 출력이 오답이 돼.
- 슬라이딩 윈도우에서 `min`을 들고 가려면, **윈도우에서 빠져나간 값이 최소값이었을 때만** “다시 전체를 훑어서(min 재계산)” 안전하게 갱신할 수 있어. 너도 그 의도로 `if(min == nums[start-1])`일 때만 재계산을 하려고 했지. 그런데 여기서 문제가 생기는 포인트가 있어.
    - 네 코드는 최소값이 “값(value)”로만 관리돼서, **동일한 값이 여러 개 있는 경우(중복 최소값)**에 윈도우에서 빠져나간 게 최소값이더라도 “아직 윈도우 안에 같은 최소값이 남아있는지”를 정확히 판단하기가 어려워.
    - 지금은 `min == nums[start-1]`면 무조건 재계산을 하는데, 이 자체는 오답을 만들진 않지만(느려질 뿐), 반대로 **재계산을 안 해도 되는 상황과 해야 하는 상황을 값 비교만으로 완벽히 구분할 수 없는 구조**라서, 케이스에 따라 `min`이 윈도우의 진짜 최소가 아닌 상태로 유지될 수 있는 위험한 형태야(“최소값의 위치/유효 범위”를 추적하지 않기 때문).
    - 더 근본적으로는, 이 방식이 **최솟값 후보들을 구조적으로 관리하지 못해서** 매번 운 좋게 맞아야 하는 로직이 돼. 슬라이딩 윈도우 최소값 문제(백준 11003)는 “최솟값이 빠져나갈 때만 재계산” 같은 발상으로 구현하면, 중복/경계가 섞인 입력에서 **최소값이 바뀌는 타이밍을 놓치거나** 반대로 불필요하게 재계산을 반복하게 되고, 결국 정답 보장이 어렵고 시간도 위험해져.
    - 그래서 정석 풀이는 `min`을 값 하나로 들고 가는 게 아니라, **(값, 인덱스)**를 들고 다니면서 “윈도우 밖으로 나간 인덱스는 제거”하고 “뒤에서부터 자기보다 큰 값은 제거”하는 식으로 **단조 큐(Deque)**로 관리해. 그래야 최소값이 항상 덱의 앞에 유지되고, 중복/경계도 정확히 처리돼.
- 정리하면, 너 코드가 틀리는 이유는 “현재 윈도우의 최소값을 값 하나로만 들고 가면서, 빠져나감/중복/최소 후보 교체를 인덱스 기반으로 보장하지 못하는 갱신 방식”이라서야. 이 문제는 로직을 조금 고치는 수준으로는 안정적으로 해결이 어렵고, **Deque로 최소 후보들을 유지하는 방식으로 바꿔야 정답이 보장**돼.

### 책에서의 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		StringBuilder sb = new StringBuilder();
		
		int N = Integer.parseInt(st.nextToken());
		int L = Integer.parseInt(st.nextToken());
		
		st = new StringTokenizer(br.readLine());
		Deque<Node> mydeque = new LinkedList<>();
		
		for(int i=0; i<N; i++) {
			int now = Integer.parseInt(st.nextToken());
			
			// 새로운 값이 들어올 때마다 현재 수보다 큰 값을 덱에서 제거
			while (!mydeque.isEmpty() && mydeque.getLast().value > now) {
				mydeque.removeLast();
			}
			
			mydeque.addLast(new Node(now, i));
			
			// 범위에서 벗어난 값은 덱에서 제거
			if (mydeque.getFirst().index <= i - L) {
				mydeque.removeFirst();
			}
			
			sb.append(mydeque.getFirst().value).append(' ');
		}
		
		System.out.println(sb.toString());
	}
	
	static class Node {
		public int value;
		public int index;
		
		Node(int value, int index) {
			this.value = value;
			this.index = index;
		}
	}
}
```

### Deque

<br>

![스크린샷 2026-02-03 오후 4.24.13.png](/assets/img/post/img25.png)

<br>

- 양 끝에서 데이터를 삽입하거나 삭제할 수 있는 자료구조
- 왼쪽: `addFirst()`, `removeFirst()`
- 오른쪽: `addLast()`, `removeLast()`

### 구현하기

<br>

![스크린샷 2026-02-03 오후 4.34.05.png](/assets/img/post/img26.png)

<br>

- 덱에서는 (인덱스, 숫자) 형태의 노드를 클래스로 구현하여 저장한다.
    - 덱에 `(값)`만 넣지 않고 **`(인덱스, 값)`을 같이 넣는 이유는 “언제 이 값이 윈도우에서 나가야 하는지”를 판단해야 하기 때문**
        - 슬라이딩 윈도우는 시간이 한 칸씩 앞으로 이동하면서, 윈도우 범위를 벗어난 값은 자동으로 제거돼야 하는데, 값만 가지고 있으면 그 값이 **지금 범위 안의 값인지, 이미 범위를 벗어난 값인지 구분할 방법이 없다**.
        - 인덱스를 함께 저장해야 `현재 인덱스 - 저장된 인덱스 ≥ L` 같은 조건으로 “이 노드는 이제 윈도우 밖이다”라고 정확히 판단할 수 있다.
    - **덱을 항상 “정답 후보만 남기는 구조”로 유지하기 위해서**
        - 새 값이 들어올 때 뒤에서부터 비교해서 더 큰 값들을 제거하면 덱 안의 값들은 항상 오름차순이 되고, 맨 앞에 있는 값이 항상 현재 윈도우의 최솟값이 된다.
        - 이때도 “이 값이 언제 들어온 값인지”를 알아야, 앞에서 꺼낼지 말지를 결정할 수 있으니 인덱스가 필요하다.
- **인덱스 범위가 슬라이딩 윈도우 범위 내일때**
    
    ![스크린샷 2026-02-03 오후 4.35.46.png](/assets/img/post/img27.png)
    
    - 새 노드 (3, 2)가 저장될 때 덱 뒤에서부터 비교를 시작한다.
    - (2, 5)는 (3, 2)보다 숫자가 크므로 (2, 5)는 덱에서 제거한다.
    - 이어서 (1, 1)은 (3, 2)보다 숫자가 작으므로 탐색을 멈추고 (3, 2)를 덱에 저장한다.
    - 결과를 보면 (2, 5)가 덱에서 제거되어 덱에는 (1, 1), (3, 2) 순서로 노드가 오름차순 정렬되어 있다. 바로 이것이 덱을 이용하여 **정렬 효과**를 보는 방법이다. 정리를 끝마친 상태의 덱을 보면 인덱스 범위는 1~3으로 슬라이딩 윈도우 크기를 넘지 않으므로 최솟값을 찾아도 된다. **최솟값은 덱 처음에 있는 (1, 1) 노드다.**
- **인덱스 범위가 슬라이딩 윈도우 범위 밖일때**
    
    
    ![스크린샷 2026-02-03 오후 4.37.30.png](/assets/img/post/img28.png)
    
    - 새 노드 (4, 3)은 덱 뒤에서부터 비교했을 때 (3, 2)보다 숫자가 크므로 덱에 저장된다.
    - 여기서 인덱스 범위에 의해 덱 앞쪽의 노드가 제거된다.
    - (1, 1), (3, 2), (4, 3)의 인덱스 범위는 1~4이므로 윈도우 범위인 3을 벗어난다. 최솟값은 윈도우 범위 내에서 찾기로 했으므로 (1, 1)은 덱에서 제거해야 한다.
    - 제거가 끝난 이후에 최솟값을 출력하면 2

- **전체 과정**
    
    ![스크린샷 2026-02-03 오후 5.23.18.png](/assets/img/post/img29.png)
    
    1. 최초 (1, 1)이 덱에 추가되면 비교 대상이 없고, 범위도 만족하므로 바로 1을 출력한다.
    2. (2, 5)는 (1, 1)과 숫자를 비교했을 때 더 크므로 탐색을 멈추고 덱에 추가한다. 인덱스 범위가 1~2여서 윈도우 범위를 만족하므로 다시 1을 출력한다.
    3. (3, 2)는 (2, 5)와 숫자를 비교했을 때 더 작으므로 (2, 5)를 덱에서 제거한다. (1, 1)은 여전히 (3, 2)보다 숫자가 작으므로 탐색을 멈추고 (3, 2)를 덱에 저장한다. 덱의 상태는 (1, 1), (3, 2)가 되고, 인덱스 범위 1~3 역시 윈도우 범위를 만족하므로 다시 1을 출력한다.
    
    (…생략…)
    

# 4.5 스택과 큐

## 스택과 큐의 핵심 이론

### 스택

- 스택은 삽입과 삭제 연산이 LIFO 이뤄지는 자료구조
- 후입선출은 삽입과 삭제가 한쪽에서만 일어나는 특징이 있다.

<br>

![스크린샷 2026-02-04 오후 5.14.10.png](/assets/img/post/img30.png)

<br>

- 새 값이 스택에 들어가면 top이 새 값을 가리킨다.
- 스택에서 값을 빼낼 때 pop은 top이 가리키는 값을 스택에서 빼게 되어있으므로 결과적으로 가장 마지막에 넣었던 값이 나오게 된다.
- 스택은 깊이 우선 탐색과 백트래킹 종류의 코딩테스트에 효과적이다.
- 후입선출은 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통

### 스택 용어

- **위치**
    - top: 삽입과 삭제가 일어나는 위치
- **연산**
    - push: top 위치에 새로운 데이터를 삽입하는 연산
    - pop: top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
    - peek: top 위치에 현재 있는 데이터를 단순 확인하는 연산

### 큐

- 큐는 삽입과 삭제 연산이 선입선출로 이뤄지는 자료구조
- 스택과 다르게 먼저 들어온 데이터가 먼저 나간다. 그래서 삽입과 삭제가 양방향에서 이뤄진다.

<br>

![스크린샷 2026-02-04 오후 5.34.22.png](/assets/img/post/img31.png)

<br>

- 새 값 추가는 큐의 rear에서 이뤄지고, 삭제는 큐의 front에서 이뤄진다.
- 큐는 너비 우선 탐색에서 자주 사용한다.

### 큐 용어

- rear: 큐에서 가장 끝 데이터를 가리키는 영역
- front: 큐에서 가장 앞의 데이터를 가리키는 영역
- add: rear 부분에 새로운 데이터를 삽입하는 연산
- poll: front 부분에 있는 데이터를 삭제하고 확인하는 연산
- peek: 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산

## 문제 011 : 스택으로 수열 만들기

<br>

![스크린샷 2026-02-04 오후 5.39.25.png](/assets/img/post/img32.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		int n = Integer.parseInt(br.readLine());
		int[] numArr = new int[n];
		Stack<Integer> stack = new Stack<>();
		int num = 1;
		boolean result = true;
		
		for(int i=0; i<n; i++) {
			numArr[i] = Integer.parseInt(br.readLine());
		}
		
		for(int i=0; i<n; i++) {
			if(numArr[i] >= num) { // 현재 수열 값 >= 오름차순 자연수
				while (numArr[i] >= num) { // 값이 같아질 때까지 push
					stack.push(num++);
					sb.append("+\n");
				}
				stack.pop(); // 값이 같아질 때
				sb.append("-\n");
			}
			else { // 현재 수열 값 < 오름차순 자연수
				int j = stack.pop(); // pop을 수행해 수열 원소를 꺼냄
				// 스택의 가장 위의 수가 만들어야 하는 수열의 수보다 크면 수열 출력 X
				if (j > numArr[i]) {
					System.out.println("NO");
					result = false;
					break;
				}
				else {
					sb.append("-\n");
				}
			}
		}
		if (result) System.out.println(sb.toString());
	}
}					
```

### 스택 연산 수행 방법

- 현재 수열 값 ≥ 자연수
    - 현재 수열 값이 자연수보다 크거나 같을 때까지 자연수를 1씩 증가시키며 자연수를 스택에 push가 끝나면 현재 수열을 출력하기 위해 마지막 1회만 pop한다.
    - 예를 들어 현재 수열 값이 4면 스택에는 1, 2, 3, 4를 push 하고 마지막에 1회만 pop하여 4를 출력하고 조건문을 빠져나온다. 자연수는 5가 된다.
- 현재 수열 값 < 자연수
    - 현재 수열 값보다 자연수가 크다면 pop으로 스택에 있는 값을 꺼낸다. 꺼낸 값이 현재 수열 값이거나 아닐 수 있다. 만약 아니라면 후입선출 원리에 따라 수열을 표현할 수 없으므로 NO를 출력한 후 문제를 종료하고, 현재 수열 값이라면 그대로 조건문을 빠져나온다.
    - 앞의 예를 이어 설명하면 자연수는 5, 현재 수열 값은 3이므로 스택에서 3을 꺼낸다. 현재 수열 값과 스택에서 꺼낸 값은 같으므로 계속해서 스택 연산을 수행할 수 있다. 스택에는 1, 2가 남아있으며, 자연수는 5다.

<br>

![스크린샷 2026-02-04 오후 6.13.44.png](/assets/img/post/img33.png)

<br>

### List

- **ArrayList**
    - `List<Integer> list = new ArrayList<>()`
    - 내부 구조가 배열이라 조회가 빠르고 삽입 삭제가 느리다.
    - **조회가 많고 인덱스로 자주 접근할 때 사용**
- **LinkedList**
    - `List<Integer> list = new LinkedList<>()`
    - 내부 구조가 연결 리스트라 조회가 느리고 삽입 삭제가 빠르다.
    - **중간 삽입, 삭제가 매우 잦고 노드 위치를 이미 알고있을 때 사용**
    - **Queue / Deque 용도**
        - `Queue<Integer> queue = new LinkedList<>();`

## 문제 012 : 오큰수 구하기

<br>

![스크린샷 2026-02-04 오후 6.18.13.png](/assets/img/post/img34.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		int[] A = new int[N]; // 수열 배열
		int[] ans = new int[N]; // 정답 배열
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			A[i] = Integer.parseInt(st.nextToken());
		}
		
		Stack<Integer> stack = new Stack<>();
		stack.push(0); // 처음에는 항상 스택이 비어있으므로 최초 값을 push해 초기화
		
		for(int i=1; i<N; i++) {
			// 스택이 비어있지 않고 현재 수열이 스택 top 인덱스가 가리키는 수열보다 클 경우
			while(!stack.isEmpty() && A[stack.peek()] < A[i]) {
				ans[stack.pop()] = A[i]; // 정답 배열에 오큰수를 현재 수열로 저장
			}
			stack.push(i);
		}
		
		while(!stack.empty()) {
			// 반복문을 다 돌고 나왔는데 스택이 비어있지 않다면 빌때까지
			ans[stack.pop()] = -1;
			// 스택에 쌓인 index의 정답 배열에 -1을 넣고
		}
				
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		for(int i=0; i<N; i++) {
			bw.write(ans[i] + " "); // 출력
		}
		bw.write("\n");
		bw.flush();
	}
}
```

- **시간초과 풀이 ..**
    
    ```java
    import java.util.*;
    import java.io.*;
    
    public class Main {
    	public static void main(String[] args) throws IOException {
    		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    		int N = Integer.parseInt(br.readLine());
    		int[] A = new int[N];
    		StringTokenizer st = new StringTokenizer(br.readLine());
    		StringBuilder sb = new StringBuilder();
    		
    		for(int i=0; i<N; i++) {
    			A[i] = Integer.parseInt(st.nextToken());
    		}
    		
    		for(int i=0; i<N; i++) {
    			int idx = i+1;
    			
    			if(idx < N && A[i] < A[idx]) {
    				sb.append(A[idx]).append(' ');
    			} else if (idx < N && A[i] >= A[idx]){
    				while(idx < N && A[i] >= A[idx]) {
    					idx++;
    				}
    				if(idx < N && A[i] < A[idx]) sb.append(A[idx]).append(' ');
    			}
    			
    			if(idx >= N) sb.append("-1 ");
    		}
    		
    		System.out.println(sb.toString());
    	}
    }
    ```
    

### 핵심 아이디어

- 스택에 들어오는 수가 top에 존재하는 수보다 크면 그 수는 오큰수가 된다.
- 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자에 -1을 출력해야 한다.

### 문제 푸는 순서

1. 스택이 채워져 있고 A[index] > A[top]인 경우 pop한 인덱스를 이용하여 정답 수열에 오큰수를 저장한다. pop은 조건을 만족하는 동안 계속 반복한다. 
2. 현재 인덱스를 스택에 push하고 다음 인덱스로 넘어간다.
3. 과정 1~2를 수열 길이만큼 반복한 다음 현재 스택에 남아 있는 인덱스에 -1을 저장한다.

<br>

![스크린샷 2026-02-04 오후 7.04.11.png](/assets/img/post/img35.png)

<br>

![스크린샷 2026-02-04 오후 7.04.53.png](/assets/img/post/img36.png)

<br>

## 문제 013 : 카드 게임

![스크린샷 2026-02-04 오후 7.15.32.png](/assets/img/post/img37.png)

### 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine()); // N장의 카드
		Queue<Integer> queue = new LinkedList<>();
		
		for (int i=1; i<=N; i++) {
			queue.add(i);
		}
		
		while(queue.size() > 1) {
			queue.remove();
			queue.add(queue.remove());
		}
		
		System.out.println(queue.peek());
	}
}
```

### 문제 푸는 순서

1. poll을 수행하여 맨 앞의 카드를 버린다.
2. 과정 1에 이어 바로 add를 수행해 맨 앞에 있는 카드를 가장 아래로 옮긴다.
3. 큐의 크기가 1이 될 때까지 과정 1~2를 반복한 후 큐에 남은 원소를 출력한다.

<br>

![스크린샷 2026-02-04 오후 7.29.53.png](/assets/img/post/img38.png)

<br>

## 문제 014 : 절댓값 힙 구하기

<br>

![스크린샷 2026-02-04 오후 7.39.58.png](/assets/img/post/img39.png)

<br>

### 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine()); // 연산의 개수
		PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> {
			int first_abs = Math.abs(o1);
			int second_abs = Math.abs(o2);
			if (first_abs == second_abs)
				return o1 > o2 ? 1 : -1; // 절댓값이 같으면 음수 우선 정렬하기
			else
				return first_abs - second_abs;
		});
		
		for(int i=0; i<N; i++) {
			int num = Integer.parseInt(br.readLine());
			if (num == 0) {
				if (pq.isEmpty()) System.out.println("0");
				else System.out.println(pq.poll());
			} else {
				~~~~pq.add(num);
			}
		}
	}
}
		
```

### 우선순위 큐

- 들어온 순서가 아니라 ‘우선순위가 높은 요소부터’ 꺼내는 자료구조
- 일반 큐가 FIFO(먼저 온 것이 먼저 나감)라면, 우선순위 큐는 **정렬 기준이 있는 큐**
- **핵심 개념**
    - 각 원소는 **값 + 우선순위**를 가진다.
    - `poll()`(또는 pop) 시 **가장 우선순위가 높은 원소**가 나온다.
    - 우선순위 기준은 **작을수록 높다(min-heap)** 또는 **클수록 높다(max-heap)** 로 정의할 수 있다.
- **내부 구현**
    - 힙으로 구현된다.
        - 완전 이진 트리 형태
        - 부모 노드는 자식 노드보다 항상 우선순위가 높음(힙 성질)
        - 이 구조 덕분에 삽입/삭제가 빠르다.
    - Java의 `PriorityQueue`는 **기본이 min-heap**이다.
    - `PriorityQueue<Integer> pq = new PriorityQueue<>();`
    - max-heap으로 쓰고 싶을 때
        - `PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());`
- **문법**
    - **삽입**: `pq.offer(1)`
    - **가장 우선순위 높은 값 확인**: `pq.peek()`
    - **가장 우선순위 높은 값 제거 + 반환**: `pq.poll()`
    - **Comparator**
        - `compare(o1, o2) < 0` 이면 **o1이 o2보다 “작다(우선순위가 높다)”** 로 판단 → **o1이 앞(먼저 나옴)**
        - `compare(o1, o2) > 0` 이면 **o1이 o2보다 “크다(우선순위가 낮다)”** → **o2가 앞**
        - `compare(o1, o2) == 0` 이면 **동급**

### 문제 푸는 순서

1. x=0일 때
    - 큐가 비어 있을 때는 0을 출력, 비어있지 않을 때는 절댓값이 최소인 값을 출력
    - 단, 절댓값이 같다면 음수를 우선하여 출력
2. x≠0일 때
    - add로 큐에 새로운 값을 추가하고 우선순위 큐 정렬 기준으로 자동 정렬한다.

![스크린샷 2026-02-04 오후 7.39.58.png](/assets/img/post/img40.png)

### 오답노트

- Comparator의 `compare`는 **반드시 int를 반환**해야 함.