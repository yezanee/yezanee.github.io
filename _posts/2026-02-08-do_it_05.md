---
title: 5. 정렬
date: 2026-02-08 12:01:00 +0900
categories:
  - 알고리즘
  - Do it! 알고리즘 코딩테스트 자바
tags:
  - 알고리즘
  - 코딩테스트
---

# 5.1 버블 정렬

- 정렬 알고리즘 정의

<br>

| 정렬 알고리즘 | 정의 |
| --- | --- |
| 버블 (bubble) | 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식 |
| 선택 (selection) | 대상에서 가장 크거나 작은 데이터를 찾아 선택하는 과정을 반복하면서 정렬하는 방식 |
| 삽입 (insertion) | 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식 |
| 퀵 (quick) | pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식 |
| 병합 (merge) | 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식 |
| 기수 (radix) | 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식 |

<br>

## 버블 정렬의 핵심 이론

- 두 인접한 데이터의 크기를 비교해 정렬하는 방법

<br>

![img](/assets/img/post/img41.png)

<br>

- **버블 정렬 과정**
    1. 비교 연산이 필요한 루프 범위를 설정한다.
    2. 인접한 데이터 값을 비교한다.
    3. swap 조건에 부합하면 swap 연산을 수행한다.
    4. 루프 범위가 끝날 때까지 2~3을 반복한다.
    5. 정렬된 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
    6. 비교 대상이 없을 때까지 1~5를 반복한다.

<br>

---

## 문제 015 : 수 정렬하기 1

<br>

![img](/assets/img/post/img42.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
		for(int i=0; i<N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
		
		Arrays.sort(arr);
		
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		for(int i=0; i<N; i++) {
			bw.write(arr[i]+"\n");
		}
		
		bw.flush();
		bw.close();
	}
}
```

<br>

### 책에서의 풀이

<br>

![img](/assets/img/post/img43.png)

<br>

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
		for(int i=0; i<N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
		
		for (int i=0; i<N-1; i++) {
			for (int j=0; j<N-1-i; j++) {
				if (arr[j] > arr[j+1]) {
					int temp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = temp;
				}
			}
		}
		
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		for(int i=0; i<N; i++) {
			bw.write(arr[i]+"\n");
		}
		
		bw.flush();
		bw.close();
	}
}
```

<br>

- `j < N-1-i`는 이미 뒤쪽에 정렬된 값(i개)을 다시 비교하지 않기 위해 줄여가는 범위.

<br>

---

## 문제 016 : 버블 정렬 프로그램 1

<br>

![img](/assets/img/post/img44.png)

<br>

### 풀이 (틀림)

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int[] A = new int[N+1];
		boolean change = false;
		for (int i=1; i <= N+1; i++) {
			change = false;
			for (int j=1; j <= N-i; j++) {
				if (A[j] > A[j+1]) {
					change = true;
					int temp = A[j];
					A[j] = A[j+1];
					A[j+1] = temp;
				}
			}
			if (change == false) {
				System.out.println(i);
				break;
			}
		}									
	}
}
```

<br>

### 문제 분석하기

- **버블 정렬의 swap이 한 번도 일어나지 않은 루프가 언제인지 알아내는 문제**
- 버블 정렬의 이중 for문에서 안쪽 for문 전체를 돌 때 swap이 일어나지 않았다 → 이미 모든 데이터가 정렬됐다
- 하지만 이 문제는 버블 정렬로 문제를 풀면 시간을 초과할 수 있다. 다른 아이디어 필요
    - 안쪽 루프는 1 ~ n-i까지 즉, 왼쪽에서 오른쪽으로 이동하면서 swap을 수행
        - 특정 데이터가 안쪽 루프에서 swap의 왼쪽으로 이동할 수 있는 최대거리가 1이라는 뜻
    - 데이터 정렬 전 index와 정렬 후 index를 비교해 가장 많이 이동한 값을 찾으면 된다.

<br>

### 책에서의 문제 풀이

<br>

```java
public class P1377_버블정렬1 {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(reader.readLine());
        mData[] A = new mData[N];

        for (int i = 0; i < N; i++) {
            A[i] = new mData(Integer.parseInt(reader.readLine()), i);
        }

        Arrays.sort(A);   // A 배열 정렬(O(nlogn) 시간 복잡도)

        int Max = 0;
        for (int i = 0; i < N; i++) {
            // 정렬 전 index - 정렬 후 index 계산의 최댓값 저장하기
            if (Max < A[i].index - i)
                Max = A[i].index - i;
        }

        System.out.println(Max + 1);
    }
}

class mData implements Comparable<mData> {
    int value;
    int index;

    public mData(int value, int index) {
        super();
        this.value = value;
        this.index = index;
    }

    @Override
    public int compareTo(mData o) {
        // value 기준 오름차순 정렬하기
        return this.value - o.value;
    }
}

```

<br>

- 값과 인덱스를 함께 저장한다.
- value 기준으로 정렬한다.
- 원소가 왼쪽으로 몇 칸 이동했는지 (A[i].index - i)
    - 음수 → 오른쪽으로 이동 (버블 정렬에 영향 없음)
    - 양수 → 왼쪽으로 이동 (중요!)
- 버블 정렬은 한 번에 왼쪽으로 1칸밖에 못 가기 때문에, 가장 많이 왼쪽으로 이동해야 하는 원소의 이동 횟수가 전체 정렬 횟수를 결정하고, 마지막에 swap이 없는지를 확인하는 pass가 한 번 더 필요해서 +1을 한다.
    - 버블 정렬에서 가장 늦게 제자리를 찾는 원소를 구하는 것

<br>

---

# 5.2 선택 정렬

<br>

## 선택 정렬의 핵심 이론

<br>

- 선택 정렬은 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n²)으로 효율적이지 않아 코딩 테스트에서는 많이 사용하지 않는다.

<br>

![img](/assets/img/post/img45.png)

<br>

- 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것이 선택 정렬의 핵심
- **선택 정렬 과정**
    ① 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
    ② 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
    ③ 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
    ④ 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

<br>

---

## 문제 017 : 내림차순으로 자릿수 정렬하기

<br>

![img](/assets/img/post/img46.png)

<br>

### 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String str = br.readLine();
		int len = str.length();
		int[] num = new int[len];
		
		for(int i=0; i<len; i++) {
			num[i] = Integer.parseInt(str.substring(i, i+1));
		}
		
		for(int i=0; i<len; i++) {
			int max = i;
			for (int j=i+1; j<len; j++) { // 최댓값 위치 찾기
				if(num[max] < num[j]) max = j; 
			}
			if (num[i] < num[max]) { // 찾은 최댓값을 현재 자리로 교환
				int temp = num[i];
				num[i] = num[max];
				num[max] = temp;
			}
		}
		
		for(int i=0; i<len; i++) System.out.print(num[i]);
	}
}
```

<br>

### 오답노트

- 값이 아니라 index 저장

<br>

---

# 5.3 삽입 정렬

<br>

## 삽입 정렬의 핵심 이론

<br>

- 삽입 정렬은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 평균 시간 복잡도는 O(n²)으로 느린 편이지만 구현하기 쉽다.

<br>

![img](/assets/img/post/img47.png)

<br>

- 선택된 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 삽입 정렬의 핵심이다.
- **삽입 정렬 과정**
    ① 현재 index에 있는 데이터 값을 선택한다.
    ② 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
    ③ 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
    ④ 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
    ⑤ 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.

<br>

- 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다.

<br>

---

## 문제 018 : ATM 인출 시간 계산하기

<br>

![img](/assets/img/post/img48.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine()); // 사람 수
		int[] P = new int[N]; // 사람들이 돈을 인출하는데 걸리는 시간
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			P[i] = Integer.parseInt(st.nextToken());
		}
		
		Arrays.sort(P);
		
		
		int sum = P[0];
		int current = P[0];
		for(int i=1; i<N; i++) {
			current += P[i];
			sum += current;
		}
		
		System.out.println(sum);
	}
}
```

<br>

- 삽입정렬

<br>

![img](/assets/img/post/img49.png)

<br>

### 오답노트

- 누적합을 또 누적하는 문제 → 누적 시간과 정답을 절대 하나의 변수로 처리하면 안 된다.

<br>

### 책에서의 풀이

<br>

```java
import java.util.*;
import java.io.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine()); // 사람 수
		int[] P = new int[N]; // 사람들이 돈을 인출하는데 걸리는 시간
		int[] S = new int[N];
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			P[i] = Integer.parseInt(st.nextToken());
		}
		
		for(int i=1; i<N; i++) { // 삽입 정렬
			int insert_point=i;
			int insert_value=P[i];
			
			for(int j= i-1; j>= 0; j--) {
				if (P[j] < P[i]) {
            insert_point = j + 1;
            break;
        }
        if (j == 0) {
            insert_point = 0;
        }
	    }
	    
	    for (int j = i; j > insert_point; j--) {
        P[j] = P[j - 1];
		  }
		
		  P[insert_point] = insert_value;
		}

		S[0] = P[0];
		for(int i=1; i<N; i++) {
			S[i] = S[i-1] + P[i];
		}
		int sum = 0;
		for(int i=0; i<N; i++) {
			sum = sum + S[i];
		}
		
		System.out.println(sum);
	}
}
```

<br>

---

# 5.4 퀵 정렬

## 퀵 정렬의 핵심 이론

- 퀵 정렬은 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘.
- 기준 값을 어떻게 선정하는 지가 시간 복잡도에 많은 영향을 미치는데 평균적인 시간 복잡도는 O(nlogn)이다.
- pivot을 중심으로 계속 데이터를 **2개의 집합으로 나누면서 정렬하는 것**이 퀵 정렬의 핵심
    
    ![스크린샷 2026-02-16 오전 1.59.43.png](/assets/img/img50.png)

<br>

### 퀵 정렬 과정

1. 데이터를 분할하는 pivot을 설정한다. (위 그림의 경우 가장 오른쪽 끝을 pivot으로 설정.)
2. pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
    
    2.1 start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동한다.
    
    2.2 end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
    
    2.3 start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다. 
    
    2.4 start와 end가 만날 때까지 2.1 ~ 2.3 를 반복한다.
    
    2.5 start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
    
3. 분리 집합에서 각각 다시 pivot을 선정한다.
4. 분리 집합의 요소가 1개 이하가 될 때까지 과정 1~3을 반복한다.

<br>

## 문제 019 : K번째 수 구하기

![스크린샷 2026-02-17 오후 8.37.06.png](/assets/img/img51.png)

<br>

### 풀이

- **pivot == K:** K번째 수를 찾은 것이므로 알고리즘을 종료한다.
- **pivot > K:** pivot의 왼쪽 부분에 K가 있으므로 왼쪽만 정렬을 수행한다.
- p**ivot < K:** pivot의 오른쪽 부분에 K가 있으므로 오른쪽만 정렬을 수행한다.

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenzier(br.readLine());
		
		int N = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());
		
		st = new StringTokenizer(br.readLine());
		int[] A = new int [N];
		for(int i=0; i<N; i++) {
			A[i] = Integer.parseInt(st.nextToken());
		}
		quickSort(A, 0, N-1, K-1);
		System.out.println(A[K-1]);
	}
	
	public static void quickSort(int[] A, int S, int E, int K) {
		if (S < E) {
			int pivot = parition(A, S, E);
			if (pivot == K) return;
			else if (K < pivot) quickSort(A, S, pivot-1, K);
			else quickSort(A, pivot+1, E, K);
		}
	}
	
	public static int partition(int[] A, int S, int E) {
		if (S + 1 == E) {
			if(A[S] > A[E]) swap(A, S, E);
			return E;
		}
		int M = (S + E)/2;
		swap(A, S, M);
		int pivot = A[S];
		int i = S + 1, j = E;
		while (i<=j) {
			
}
```

<br>

# 5.5 병합 정렬

- 병합 정렬은 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘입니다.
- 병합 정렬의 시간 복잡도 평균은 O(nlogn)입니다.

<br>

## 병합 정렬의 핵심 이론

![스크린샷 2026-02-22 오전 12.34.24.png](/assets/img/img52.png)

<br>

### 병합 정렬 수행 방식

- 8개의 그룹으로 나눈다.
- 이 상태에서 2개씩 그룹을 합치며 오름차순 정렬 → 그 결과 (32, 42), (24, 60), (5, 15), (45, 90)
- 이어서 2개씩 그룹을 합치며 다시 오름차순 정렬 → 그 결과 (24, 32, 42, 60), (5, 15, 45, 90)
- 이런 방식으로 병합 정렬 과정을 거치면 (5, 15, 24, 32, 42, 45, 60, 90)이 되어 전체를 오름차순으로 정렬할 수 있다.

![스크린샷 2026-02-22 오전 12.39.17.png](/assets/img/img53.png)

<br>

### 2개의 그룹을 병합하는 과정

- 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합한다.
- 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 **작은 값**을 결과 배열에 추가하고 포인터를 **오른쪽으로 1칸 이동**시킨다.
- 이 방식 반드시 숙지하기!

<br>

## 문제 020 : 수 정렬하기 2

![스크린샷 2026-02-22 오전 12.46.50.png](/assets/img/img54.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static int[] A, tmp;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		int N = Integer.parseInt(br.readLine());
		
		A = new int[N+1]; // 1-based
		tmp = new int[N+1];
		
		for(int i=1; i<=N; i++) {
			A[i] = Integer.parseInt(br.readLine());
		}
		
		merge_sort(1, N);
		
		for(int i=1; i<=N; i++) {
			bw.write(A[i] + "\n");
		}
		
		bw.flush();
		bw.close();
	}
	
	private static void merge_sort(int s, int e) {
		if (e-s < 1) return; // 구간 길이가 1 이하 = 이미 정렬된 상태 (s >= e)
		int m = s + (e-s) / 2; // 정수 오버플로우 방지
		
		merge_sort(s, m);
		merge_sort(m+1, e);
		
		for(int i=s; i<=e; i++) {
			tmp[i] = A[i];
		}
		
		int k = s;
		int index1 = s;
		int index2 = m + 1;
		while (index1 <= m && index2 <= e) {
			// 양쪽 그룹의 index가 가리키는 값을 비교해 더 작은 수를 선택해 배열에 저장하고,
      // 선택된 데이터의 index 값을 오른쪽으로 한 칸 이동하기
			if (tmp[index1] > tmp[index2]) {
			  A[k] = tmp[index2];
	      k++;
        index2++;
      } else {
        A[k] = tmp[index1];
        k++;
	      index1++;
      }
		}
		
		while (index1 <= m) { // 한쪽 그룹이 모두 선택된 후 남아있는 값 제거하기
			A[k] = tmp[index1];
			k++;
			index1++;
		}
		
		while(index2 < e) {
			A[k] = tmp[index2];
			k++;
			index2++;
		}
	}
}
```

<br>

## 문제 021 : 버블 정렬 프로그램 2

![스크린샷 2026-02-22 오전 1.27.38.png](/assets/img/img55.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static int[] A, tmp;
	public static long result;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		A = new int[N+1]; // 1-based
		tmp = new int[N+1];
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		for(int i=1; i<=N; i++) {
			A[i] = Integer.parseInt(st.nextToken());
		}
		
		result = 0;
		merge_sort(1, N);
		System.out.println(result);
	}
	
	private static void merge_sort(int s, int e) {
		if (e-s < 1) return; // 구간 길이가 1 이하 = 이미 정렬된 상태 (s >= e)
		int m = s + (e-s) / 2; // 정수 오버플로우 방지
		
		merge_sort(s, m);
		merge_sort(m+1, e);
		
		for(int i=s; i<=e; i++) {
			tmp[i] = A[i];
		}
		
		int k = s;
		int index1 = s;
		int index2 = m + 1;
		while (index1 <= m && index2 <= e) {
			// 양쪽 그룹의 index가 가리키는 값을 비교해 더 작은 수를 선택해 배열에 저장하고,
      // 선택된 데이터의 index 값을 오른쪽으로 한 칸 이동하기
			if (tmp[index1] > tmp[index2]) {
			  A[k] = tmp[index2];
			  result = result + index2 - k; // 뒤쪽 데이터 값이 작은 경우 (index-k)는 왼쪽에 남아있는 원소 개수
	      k++;
        index2++;
      } else {
        A[k] = tmp[index1];
        k++;
	      index1++;
      }
		}
		
		while (index1 <= m) { // 한쪽 그룹이 모두 선택된 후 남아있는 값 제거하기
			A[k] = tmp[index1];
			k++;
			index1++;
		}
		
		while(index2 < e) {
			A[k] = tmp[index2];
			k++;
			index2++;
		}
	}
}
```

<br>

# 5.6 기수 정렬

- 기수 정렬은 값을 비교하지 않는 정렬
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교
- 기수 정렬의 시간 복잡도는 O(kn)이고, k는 데이터의 자릿수를 말한다.

<br>

## 기수 정렬의 핵심 이론

- 기수 정렬은 10개의 큐를 이용한다.
- 각 큐는 값의 자릿수를 대표한다.

![스크린샷 2026-02-22 오전 1.43.10.png](/assets/img/img56.png)


<br>

### 기수 정렬 수행 방식

- 원본 배열은 16, 80, 18, 77, 03, 24, 88, 23
- 먼저 일의 자릿수 기준으로 배열 원소를 큐에 집어넣는다.
- 그 다음 0번째 큐부터 9번째 큐까지 pop을 진행한다. → 80, 03, 23, 24, 16, 77, 18, 88
- 이어서 십의 자릿수를 기준으로 같은 과정을 진행한다.
- 마지막 자릿수를 기준으로 정렬할 때까지의 앞의 과정을 반복한다.
- 시간 복잡도가 가장 짧은 정렬. 정렬해야하는 데이터 수가 많을 때 이용

<br>

## 문제 022 : 수 정렬하기 3

![스크린샷 2026-02-22 오전 1.45.05.png](/assets/img/img57.png)

<br>

### 풀이

```java
import java.util.*;
import java.io.*;

public class Main {
	public static int N;
	public static int[] A;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		N = Integer.parseInt(br.readLine());
		A = new int[N];
		
		for(int i=0; i<N; i++) {
			A[i] = Integer.parseInt(br.readLine());
		}
		
		radis_sort(A, 5);
		
		for(int i=0; i<N; i++) {
			bw.write(A[i] + "\n");
		}
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	private static void radis_sort(int[] A, int max) {
		int[] output = new int[A.length];
		int jarisu = 1;
		int count = 0;
		
		while (count != max) {
			int[] bucket = new int[10];
			
			for(int i=0; i < A.length; i++) {
				bucket[(A[i] / jarisu) % 10]++;
			}
			
			for(int i=1; i<10; i++) {
				bucket[i] += bucket[i-1];
			}
			
			for(int i=A.length-1; i>=0; i--) {
				output[bucket[(A[i] / jarisu % 10)] - 1] = A[i];
				bucket[(A[i] / jarisu) % 10]--;
			}
			
			for(int i=0; i<A.length; i++) {
				A[i] = output[i];
			}
			
			jarisu = jarisu * 10;
			count++;
		}
		
	}
}
```