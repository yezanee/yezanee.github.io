---
title: "[프로그래머스] 더 맵게"
date: 2025-09-01 12:00:00 +0900
categories: [algorithm, 코딩테스트]
tags: [algorithm, 코딩테스트]
---


## ▪︎  문제

---

[프로그래머스 더 맵게](https://school.programmers.co.kr/learn/courses/30/lessons/42626)

<br>

## ▪︎  알고리즘 설계

---

- 가장 작은 두 개의 음식을 계속 섞어야 하므로 **최소 힙** 자료구조가 적합.
- PriorityQueue를 사용하면 매번 최솟값을 O(log N)에 꺼내고 삽입할 수 있음
- 모든 음식이 K 이상이 될 때까지 반복
- 만약 마지막까지도 K 미만의 음식이 존재한다면 -1 반환

<br>

## ▪︎  코드

---

```java
import java.util.*;

class Solution {
    public int solution(int[] scoville, int K) {
        int cnt = 0;
        
        // 최소 힙으로 교체 (정렬 반복 제거)
        PriorityQueue<Integer> pq = new PriorityQueue<>();
          for (int s : scoville) pq.offer(s);

           // 두 개 이상 있고, 최솟값이 K 미만인 동안만 섞기
           while (pq.size() > 1 && pq.peek() < K) {
           int a = pq.poll();      // 최솟값
            int b = pq.poll();      // 두 번째 최솟값
            pq.offer(a + 2 * b);    // 새 음식 삽입
            cnt++;
        }

        // 모두 K 이상인지 최종 검증
        return (pq.peek() != null && pq.peek() >= K) ? cnt : -1;
    }
}
```


<br>

## ▪︎  시간복잡도

---

`O(N log N)`

<br>

## ▪︎  틀린 이유

---

```java
import java.util.*;

class Solution {
    public int solution(int[] scoville, int K) {
        int cnt = 0;
        int i = 0;
        
        Arrays.sort(scoville);

        while(true) {
            
            if (i == scoville.length - 1) {
                
                if(scoville[scoville.length - 1] < K) {
                    cnt = -1;
                    break;
                }
                
                break;
            }
            
            if (scoville[i] < K) {
                scoville[i+1] = scoville[i] + (scoville[i+1] * 2);
                cnt++;
                i++;
                Arrays.sort(scoville);
            } else {
                i++;
            }
        }
        
        return cnt;
    }
}
```

- 시간 초과 문제 발생 ••
    - Arrays.sort()를 while 루프 안에서 계속 사용함 → O(N log N)을 매번 수행

<br>

## ▪︎  느낀점 / 기억할 정보

---

- **반복적으로 최소값을 꺼내야 하는 문제는 PriorityQueue(힙)을 우선 고려하자.**
- Arrays.sort()를 루프마다 쓰는 것은 성능상 위험
- "N log N" 연산이 한 번일 때는 괜찮지만, 반복문 안에 들어가면 "N log N * 반복횟수"로 시간 초과가 발생할 수 있다.
- PriorityQueue는 삽입/삭제 모두 log N이라 정렬 반복보다 훨씬 효율적
- 알고리즘 문제에서 "**가장 작은 것, 가장 큰 것**"을 **반복적**으로 뽑아야 한다면 정렬보다 힙 구조가 최적이다.