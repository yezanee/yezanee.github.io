<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://yezanee.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yezanee.github.io/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-07-22T18:05:39+09:00</updated><id>https://yezanee.github.io/feed.xml</id><title type="html">yezanee</title><entry><title type="html">[백준 2042] 구간 합 구하기</title><link href="https://yezanee.github.io/posts/segment-tree/" rel="alternate" type="text/html" title="[백준 2042] 구간 합 구하기" /><published>2025-07-22T12:00:00+09:00</published><updated>2025-07-22T12:00:00+09:00</updated><id>https://yezanee.github.io/posts/segment-tree</id><content type="html" xml:base="https://yezanee.github.io/posts/segment-tree/"><![CDATA[<h2 id="︎--문제">▪︎  문제</h2>

<hr />

<p>https://www.acmicpc.net/problem/2042</p>

<p><br /></p>

<h2 id="︎--알고리즘-설계">▪︎  알고리즘 설계</h2>

<hr />

<ul>
  <li><strong>세그먼트 트리?</strong>
    <ul>
      <li>배열의 특정 구간 합, 최댓값, 최솟값 등을 빠르게 구하기 위해 만든 트리구조</li>
      <li>세그먼트 트리의 핵심 아이디어
        <ul>
          <li>배열을 트리로 표현!</li>
          <li>
            <p>각 노드는 <strong>자신이 담당하는 구간의 합</strong>을 저장</p>

            <p><img src="assets/img/post/segment-tree.png" alt="배열 [5, 8, 6, 3, 2].png" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="︎--코드">▪︎  코드</h2>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">,</span> <span class="no">K</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="n">tree</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>

        <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 배열 크기</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 값 변경 횟수</span>
        <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 구간 합 구하는 횟수</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span> <span class="c1">// 입력 값을 저장할 배열</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span> <span class="o">*</span> <span class="mi">4</span><span class="o">];</span> <span class="c1">// 세그먼트 트리는 보통 4배 크기 할당</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// 세그먼트 트리 초기화 (구간 합을 미리 계산해서 트리에 저장)</span>
        <span class="n">init</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">M</span> <span class="o">+</span> <span class="no">K</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 연산 종류 (1: 값 변경, 2: 구간합) </span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 값 변경 (b번째 수를 c로 변경)</span>
                <span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span> <span class="c1">// 변경된 값의 차이만큼 갱신</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// 원본 배열도 갱신</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 구간 합 출력 (b번째~c번째 구간합)</span>
                <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 세그먼트 트리 초기화</span>
    <span class="kd">static</span> <span class="kt">long</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// node: 현재 세그먼트 트리의 노드 번호, start: 현재 구간의 시작 인덱스, end: 현재 구간의 끝 인덱스</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 리프 노드인 경우</span>
            <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">];</span> <span class="c1">// 리프 노드인 경우 배열의 값을 그대로 저장</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// 중간 인덱스</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="n">init</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span> <span class="o">+</span> <span class="n">init</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span> <span class="c1">// 왼쪽 자식 노드와 오른쪽 자식 노드의 합을 저장</span>
    <span class="o">}</span>

    <span class="c1">// 특정 구간 합 구하기</span>
    <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 구간이 완전히 벗어난 경우</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 구간이 완전히 포함된 경우</span>
            <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 왼쪽 자식 노드와 오른쪽 자식 노드의 합을 저장</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">sum</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">+</span> <span class="c1">// 왼쪽 자식 노드의 합</span>
               <span class="n">sum</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span> <span class="c1">// 오른쪽 자식 노드의 합</span>
    <span class="o">}</span>

    <span class="c1">// 특정 원소 값 갱신</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">long</span> <span class="n">diff</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span> <span class="c1">// 인덱스가 현재 구간에 포함되지 않음</span>
        <span class="o">}</span>
        <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="o">;</span> <span class="c1">// 현재 노드 값 갱신</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 리프 노드가 아닌 경우</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">// 중간 인덱스</span>
            <span class="n">update</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span> <span class="c1">// 왼쪽 자식 노드 갱신</span>
            <span class="n">update</span><span class="o">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span> <span class="c1">// 오른쪽 자식 노드 갱신</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h2 id="︎--시간복잡도">▪︎  시간복잡도</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">O(log N)</code></p>

<p><br /></p>

<h2 id="︎--틀린-이유">▪︎  틀린 이유</h2>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
		<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		
    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 개수</span>
		<span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 수의 변경이 일어나는 횟수</span>
		<span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 구간의 합을 구하는 횟수</span>
		
		<span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span> <span class="c1">// 숫자들의 배열</span>
		
		<span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
		
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">M</span><span class="o">+</span><span class="no">K</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			
			<span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">numbers</span><span class="o">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
				<span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
				<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
					<span class="n">sum</span> <span class="o">+=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
				<span class="o">}</span>
				
				<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
			<span class="o">}</span> 		
		<span class="o">}</span>
		
		<span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
		<span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>나는 위와 같이 배열로 접근하는 것만 생각했는데, 계속 런타임 에러가 발생했었다.</li>
  <li>이 문제는 데이터 범위 때문에 배열로 풀게 되면 제한 시간 안에 절대 풀지 못한다.
    <ul>
      <li>값 변경에 대한 조건이 있으므로 누적합 배열도 안된다.</li>
    </ul>
  </li>
  <li>따라서, <strong>세그먼트 트리</strong>라는 걸 이용했어야 한다.</li>
  <li><strong>배열은 구간합 쿼리와 값 변경이 둘 다 자주 일어나면 시간복잡도 O(N)
→ 시간 초과
→ 세그먼트 트리/BIT 이용하기</strong></li>
</ul>

<p><br /></p>

<h2 id="︎--느낀점--기억할-정보">▪︎  느낀점 / 기억할 정보</h2>

<hr />

<ul>
  <li>세그먼트 트리는 구간의 합, 구간의 최솟값, 구간의 최댓값 등을 빠르게 구할 때 사용한다.</li>
  <li>단순한 구간합을 구하는 문제 → 누적합 이용</li>
  <li><strong>중간에 수의 변경이 빈번하게 발생</strong> → <strong>세그먼트 트리 이용</strong></li>
</ul>]]></content><author><name></name></author><category term="algorithm" /><category term="코딩테스트" /><category term="algorithm" /><category term="코딩테스트" /><summary type="html"><![CDATA[▪︎ 문제]]></summary></entry></feed>